#!/usr/bin/ruby

require './../src/RbLearning'
require 'csv'

train = DataManager.new("./input/lol.csv")
data_y = train.remove('label')

nn = NeuroNet.new

data_x = train.matrix
data_y = Matrix.set(data_y.map do |i|
	tmp = [0] * 10
	tmp[i.to_i] = 1
	tmp
end)

data_x.normalize(255)

l1 = NetLayer.new(data_x.size_x, 200, 'reLu', 0.01)
l2 = NetLayer.new(200, 50, 'reLu', 0.001)
l3 = NetLayer.new(50, 1, 'reLu', 0, 0.01)

# layers = [l1]
# layers = [l1, l2]
layers = [l1, l2, l3]

start = Time.now

(0...300).each do |ep|
	batch_x, batch_y = train.batch(data_y, 32)
	it = data_y.size_y / batch_x.size_y
	(0...it).each do |i|
		printF =  i % 1 == 0
		layers = nn.train(layers, batch_x, batch_y, printF)
		puts "epoch: #{ep} iteration: #{i}"
	end
end

finish = Time.now

puts finish - start
exit

(0...1).each do |ep|
	# batch_x, batch_y = train.batch(data_y, 32)
	# it = data_y.size_y / batch_x.size_y
	(0...3000).each do |i|
		printF =  i % 1 == 0
		layers = nn.train(layers, data_x, data_y, printF)
		puts "epoch: #{ep} iteration: #{i}"
	end
end


tests = DataManager.new("./input/test.csv")
m = tests.matrix

x = Matrix.setVectorizedMatrix(m[0...m.size_y * m.size_x], m.size_y, m.size_x)

zs, pred = nn.feedForward(layers, x)
# pred.last.printM(5)

CSV.open("./res2.csv", "wb") do |csv|
	csv << ['ImageId', 'Label']
	m = pred.last.get2DArr
	(0...pred.last.size_y).each do |i|
		csv <<  [i + 1, m[i].each_with_index.max[1]]
	end
end
